
1、java分了5片内存：
    寄存器、本地方法区、方法区、栈、堆。

2、堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。

3、成员变量存在于堆内存中。静态变量存在于方法区中。

4、静态代码块：可以完成类的初始化。
    静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。
    如果和主函数在同一类中，优先于主函数执行。

5、静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块  构造代码块  构造函数。

6、单例设计模式：保证一个类在内存中的对象唯一性。

    比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，
    就需要该配置文件对象在内存中是唯一的。

    Runtime()方法就是单例设计模式进行设计的。

    1，私有化构造函数；
    2，创建私有并静态的本类对象；
    3，定义公有并静态的方法，返回该对象。

7、抽象关键字abstract和哪些不可以共存？final ,	private , static
    抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。

8、类与类之间存在着继承关系，类与接口中间存在的是实现关系。
    继承用extends  ；实现用implements ；
    接口与接口之间存在着继承关系，接口可以多继承接口。

9、多态在子父类中的成员上的体现的特点：
    成员变量 --- 编译运行都看 = 左边。
    成员函数 --- 编译看 = 左边，运行看 = 右边。
    静态函数 --- 编译运行都看 = 左边。

10、Class getClass()：获取任意对象运行时的所属字节码文件对象。
    通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。

11、如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。
    A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。

12、如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
    注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。

13、为什么内部类可以直接访问外部类中的成员呢？
    那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this
    内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。
    当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。？？？？？？？？？？？

14、try对应多个catch时，如果有父类的catch语句块，一定要放在下面。

15、throw 和throws关键字的区别：
   throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。
   throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。

16、Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，
    也就说这个异常是编译时不被检查的异常。

17、System.exit(0); //退出jvm，只有这种情况finally不执行。

18、当异常出现后，在子父类进行覆盖时，有了一些新的特点：
   1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。
   2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。

19、如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，
    如果子类的覆盖的方法中出现了异常，只能try不能throws。
    如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，
    这样，子类的方法上是不需要throws声明的。










