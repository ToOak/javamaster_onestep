
1、java分了5片内存：
    寄存器、本地方法区、方法区、栈、堆。

2、堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。

3、成员变量存在于堆内存中。静态变量存在于方法区中。

4、静态代码块：可以完成类的初始化。
    静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。
    如果和主函数在同一类中，优先于主函数执行。

5、静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块  构造代码块  构造函数。

6、单例设计模式：保证一个类在内存中的对象唯一性。

    比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，
    就需要该配置文件对象在内存中是唯一的。

    Runtime()方法就是单例设计模式进行设计的。

    1，私有化构造函数；
    2，创建私有并静态的本类对象；
    3，定义公有并静态的方法，返回该对象。

7、抽象关键字abstract和哪些不可以共存？final ,	private , static
    抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。

8、类与类之间存在着继承关系，类与接口中间存在的是实现关系。
    继承用extends  ；实现用implements ；
    接口与接口之间存在着继承关系，接口可以多继承接口。

9、多态在子父类中的成员上的体现的特点：
    成员变量 --- 编译运行都看 = 左边。
    成员函数 --- 编译看 = 左边，运行看 = 右边。
    静态函数 --- 编译运行都看 = 左边。

10、Class getClass()：获取任意对象运行时的所属字节码文件对象。
    通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。

11、如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。
    A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。

12、如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
    注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。

13、为什么内部类可以直接访问外部类中的成员呢？
    那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this
    内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。
    当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。？？？？？？？？？？？

14、try对应多个catch时，如果有父类的catch语句块，一定要放在下面。

15、throw 和throws关键字的区别：
   throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。
   throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。

16、Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，
    也就说这个异常是编译时不被检查的异常。

17、System.exit(0); //退出jvm，只有这种情况finally不执行。

18、当异常出现后，在子父类进行覆盖时，有了一些新的特点：
   1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。
   2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。

19、如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，
    如果子类的覆盖的方法中出现了异常，只能try不能throws。
    如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，
    这样，子类的方法上是不需要throws声明的。

20、脚标越界异常（IndexOutOfBoundsException）包括数组、字符串；
    空指针异常（NullPointerException）
    类型转换异常：ClassCastException
    没有这个元素异常：NullPointerException

21、进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。
    线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。

22、一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，
    每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。
    jvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。
    当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，
    所以由单独一个线程来负责垃圾回收。

23、随机性的原理：因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。

24、定义同步是有前提的：
    1，必须要有两个或者两个以上的线程，才需要同步。
    2，多个线程必须保证使用的是同一个锁。

25、同步代码块和同步函数的区别？
    同步代码块使用的锁可以是任意对象。
    同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。
    在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。

26、请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。
   //懒汉式：延迟加载方式。
   当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。
   为了效率问题，通过双重判断的形式解决。
   class Single{
   	private static Single s = null;
   	private Single(){}
   	public static Single getInstance(){ //锁是谁？字节码文件对象；
   		if(s == null){
   			synchronized(Single.class){
   				if(s == null)
   					s = new Single();
   			}
   		}
   		return s;
   	}
   }

27、同步死锁：通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。

28、等待唤醒机制：涉及的方法：
    wait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。
    notify：唤醒线程池中某一个等待线程。
    notifyAll:唤醒的是线程池中的所有线程。

29、注意：
    1：这些方法都需要定义在同步中。
    2：因为这些方法必须要标示所属的锁。
        你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。
    3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？
   	    因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。

30、wait和sleep区别： 分析这两个方法：从执行权和锁上来分析：
    wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。
    sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。
    wait：线程会释放执行权，而且线程会释放锁。
    Sleep：线程会释放执行权，但不是不释放锁。？？？？？？？？？？？？？？

31、线程的停止：通过stop方法就可以停止线程。但是这个方式过时了。
    停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。
    怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。
    第一种方式：定义循环的结束标记。
    第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。
        让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。

32、---------< java.lang.Thread >----------
    interrupt()：中断线程。
    setPriority(int newPriority)：更改线程的优先级。
    getPriority()：返回线程的优先级。
    toString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。
    Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。
    setDaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。
        该方法必须在启动线程前调用。
    join：临时加入一个线程的时候可以使用join方法。
    当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。
        A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。

33、Lock接口：多线程在JDK1.5版本升级时，推出一个接口Lock接口。
    同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。
    在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。
        那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。
    而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。
        而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。
        这个对象就是Condition，将Object中的三个方法进行单独的封装。
        并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。

34、StringBuffer 和 StringBuilder 的区别：
    StringBuffer线程安全。
    StringBuilder线程不安全。
    单线程操作，使用StringBuilder 效率高。
    多线程操作，使用StringBuffer 安全。

35、集合和数组的区别：
    1：数组是固定长度的；集合可变长度的。
    2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。
    3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。

36、数据结构：就是容器中存储数据的方式。

37、对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。
    集合容器在不断向上抽取过程中。出现了集合体系。
    在使用一个体系时，原则：参阅顶层内容。建立底层对象。

38、每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。
    为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。
    也就说，只要通过该接口就可以取出Collection集合中的元素，
    至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。

39、List本身是Collection接口的子接口，具备了Collection的所有方法。
    现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。

40、List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。
    |--ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。
   	|--LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。
   	|--Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。

41、在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。
    会发生.ConcurrentModificationException并发修改异常。
    导致的原因是：
        集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。
    如何解决呢？
        既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.
        通过查阅的它的子接口,ListIterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。







